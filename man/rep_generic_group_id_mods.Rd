% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/group_mods.R
\name{rep_generic_group_id_mods}
\alias{rep_generic_group_id_mods}
\title{Generic Individual-Level Moderator and Group Moderators}
\usage{
rep_generic_group_id_mods(data, model = NULL, rating_1, rating_2,
  id_mod_variable, interaction_term, group_mod = NULL, use_labs = TRUE,
  groups_eql = "none", params_eql = "none",
  n_triads = length(rating_1), n_r1_per_r2 = 1, n_r2_per_r1 = 1)
}
\arguments{
\item{data}{The dataframe.
Data should be wide, with a row for every group of participants.
At a minimum, it must contain five columns: one for rating 1, one for rating 2, one for the individual
difference moderator, one for the interaction term, and one for the group moderated variable.}

\item{model}{Optional. A model from the corresponding ReputationAnalyses model builder function. If this
is supplied, no additional arguments need to be specified.}

\item{rating_1}{Quoted column names that contain  the first rating variable. This might be P1 reports
if investigating moderation of hearsay consensus or self-reports for moderation of hearsay accuracy.
If more than one is supplied, the target-wise order must match across variables.}

\item{rating_2}{Quoted column names that contain second rating variable. For hearsay consensus or accuracy,
this would be P2 reports. If more than one is supplied, the target-wise order must match across variables.}

\item{id_mod_variable}{Quoted column names that contain the individual-level moderator of interest.
If more than one is supplied from multiple exchangeable dyads/triads,
the order must match the order of the ratings. Like P2-reports, the variable should be mean-centered
to facilitate interpretability.}

\item{interaction_term}{Quoted column names that contain the interaction term, or the product of the
mean-centered P2-report and the mean-centered moderator variable. If more than one is supplied from multiple
exchangeable dyads/triads, the target-wise order must match the order of the ratings.}

\item{group_mod}{The quoted column name that contains a group-level categorical moderator.}

\item{use_labs}{Logical indicating whether or not to use the group labels to create the parameter labels.
If FALSE, generic labels (grp1 to grpk, where k is the number of groups) are used.}

\item{groups_eql}{Optional. Groups that you want to constrain to be equal across some or all parameters. If
you have use_labs set to TRUE, provide a vector of group labels corresponding to the groups you want to constrain to be equal. If you
have use_labs set to FALSE, provide a vector of numbers corresponding to the position of the groups you want to constrain to be equal. If you provide
"all", all groups will be constrained to be equal.}

\item{params_eql}{Optional. Parameters that you want to constrain to be equal across the groups specified in groups_eql. You can provide
one or more specific parameters (e.g., "hc_me" for hearsay consensus main effect), or use a built-in options including "all" which constrains
all parameters to be equal across groups.}

\item{n_triads}{The number of exchangeable triads in each group. By default, this is determined by
counting the number of P1 reports. This parameter rarely needs to be changed.}

\item{n_r1_per_r2}{The number of first ratings for each second rating. Currently, only 1:1 is supported.}

\item{n_r2_per_r1}{The number of second ratings for each first rating. Currently, only 1:1 is supported.}
}
\value{
The function returns an object of class \code{\link[lavaan:lavaan-class]{lavaan}}.
}
\description{
This is a generic function for fitting a lavaan model for
individual-level moderators on two distinguishable ratings on the same target across multiple groups.
This could be P1- and P2- reports, P2- and self-reports, P1- and self-reports, or any other sets of
distinguishable ratings.
}
\details{
The parameters estimated by this model are:
\describe{
\item{rating_me}{main effect of other rating; this should correspond to correlation between ratings at average
level of moderator variable (if data were properly mean-centered).}
\item{mod_me}{The meain effect of the moderator variable; it can be interpreted as the difference in
rating_1 to differences in the individual-level moderator variable.}
\item{interaction}{This is the interaction term. It indicates the extent to which
the correlation between ratings depends on the moderator variable}
\item{v_rating_1}{variance for first rating}
\item{v_rating_2}{variance for second rating}
\item{v_mod}{variance for moderator variable}
\item{v_interaction}{variance for interaction term}
\item{int_rating_1}{intercept for first rating}
\item{int_rating_2}{intercept for second rating}
\item{int_mod}{intercept for moderator variable}
\item{int_interaction}{intercept for interaction term}
}
The function can handle up to n exchangeable triads.
}
\examples{
data("rep_sim_data")
          # Prepare data
         moderator_data <- rep_sim_data \%>\%
           dplyr::mutate(B_C_agreeableness_cent = scale(B_C_agreeableness, scale = FALSE),
                  D_A_agreeableness_cent = scale(D_A_agreeableness, scale = FALSE),
                  B_iri_perspective_cent = scale(B_iri_perspective, scale = FALSE),
                  D_iri_perspective_cent = scale(D_iri_perspective, scale = FALSE),
                  B_ptXagree_interaction = B_C_agreeableness_cent*B_iri_perspective_cent,
                  D_ptXagree_interaction = D_A_agreeableness_cent*D_iri_perspective_cent)

# build a bsaeline model examining perspective taking moderating hearsay consensus across groups (studies in this case)
agree_pt_mod_model <- rep_generic_group_id_mods (moderator_data,
                                           rating_1 = c("C_C_agreeableness", "A_A_agreeableness"),
                                           rating_2 = c("B_C_agreeableness_cent", "D_A_agreeableness_cent"),
                                           id_mod_variable = c("B_iri_perspective_cent", "D_iri_perspective_cent"),
                                           interaction_term = c("B_ptXagree_interaction", "D_ptXagree_interaction"),
                                           group_mod = "study")

         # fit model with group equality constraints:
         # if we wanted to constrain all parameters to be equal across the 2 groups, that can be done
         # by setting groups_eql and params_eql both to "all".
agree_pt_mod_model <- rep_generic_group_id_mods (moderator_data,
                                           rating_1 = c("C_C_agreeableness", "A_A_agreeableness"),
                                           rating_2 = c("B_C_agreeableness_cent", "D_A_agreeableness_cent"),
                                           id_mod_variable = c("B_iri_perspective_cent", "D_iri_perspective_cent"),
                                           interaction_term = c("B_ptXagree_interaction", "D_ptXagree_interaction"),
                                           group_mod = "study", groups_eql = "all", params_eql = "all")

}
