% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/group_mods.R
\name{rep_auto_group_mod}
\alias{rep_auto_group_mod}
\title{Reputation Analyses with Group Moderator (automatic)}
\usage{
rep_auto_group_mod(data, model = NULL, p1_reports, p2_reports,
  target_self = NULL, p1_meta = NULL, p2_meta = NULL,
  group_mod = NULL, use_labs = TRUE, groups_eql = "none",
  params_eql = "none", n_triads = length(p1_reports),
  n_p1s_per_p2s = 1, n_p2s_per_p1s = 1, n_p1s_per_ts = 1,
  n_p2s_per_ts = 1, n_ts_per_p1s = 1, n_ts_per_p2s = 1)
}
\arguments{
\item{data}{The dataframe.
Data should be wide, with a row for every group of participants.
At a minimum, it must contain three columns: one for P1-reports, one for P2-reports, and
one for targets' self-ratings.}

\item{model}{Optional. A model from the corresponding ReputationAnalyses model builder function. If this
is supplied, no additional arguments need to be specified.}

\item{p1_reports}{Optional. Quoted column names that contain P1 reports,
or ratings made by the person that knows the target directly.
If more than one is supplied, the target-wise order must match the other
rating types.}

\item{p2_reports}{Optional. Quoted column names that contain P2 reports,
or ratings made by the person that knows the target indirectly through the corresponding P1.
If more than one is supplied, the target-wise order must match the other
rating types.}

\item{target_self}{Optional. Quoted column names that contain target self-reports.
If more than one is supplied, the target-wise order must match the other
rating types.}

\item{p1_meta}{Optional. Quoted column names that contain P1 3rd person Meta-perceptions,
or P1's ratings of how they think P2 sees the target.
If more than one is supplied, the target-wise order must match the other
rating types.}

\item{p2_meta}{Optional. Quoted column names that contain P2 3rd person Meta-perceptions,
or P2's ratings of how they think P1 sees the target.
If more than one is supplied, the target-wise order must match the other
rating types.}

\item{group_mod}{The quoted column name that contains a group-level categorical moderator.}

\item{use_labs}{Logical indicating whether or not to use the group labels to create the parameter labels.
If FALSE, generic labels (grp1 to grpk, where k is the number of groups) are used.}

\item{groups_eql}{Optional. Groups that you want to constrain to be equal across some or all parameters. If
you have use_labs set to TRUE, provide a vector of group labels corresponding to the groups you want to constrain to be equal. If you
have use_labs set to FALSE, provide a vector of numbers corresponding to the position of the groups you want to constrain to be equal. If you provide
"all", all groups will be constrained to be equal.}

\item{params_eql}{Optional. Parameters that you want to constrain to be equal across the groups specified in groups_eql. You can provide
one or more specific parameters (e.g., "hc" for hearsay consensus), or use one of several built-in options including "all" which constrains
all parameters to be equal across groups and "main" which constrains just the hearsay consensus to be equal across groups (in this model).}

\item{n_triads}{The number of exchangeable triads in each group. By default, this is determined by
counting the number of P1 reports. It is rare that this parameter would need to be changed.}

\item{n_p1s_per_p2s}{The number of P1s for every P2. This defaults to 1.
Currently, only values of 1 are supported.}

\item{n_p2s_per_p1s}{The number of P2s for every P1;. This defaults to 1.
Currently, only values of 1 are supported.}

\item{n_p1s_per_ts}{The number of P1s for every target;. This defaults to 1.
Currently, only values of 1 are supported.}

\item{n_p2s_per_ts}{The number of P2s for every target;. This defaults to 1.
Currently, only values of 1 are supported.}

\item{n_ts_per_p1s}{The number of targets for every P1;. This defaults to 1.
Currently, only values of 1 are supported.}

\item{n_ts_per_p2s}{The number of targets for every P2;. This defaults to 1.
Currently, only values of 1 are supported.}
}
\value{
The function returns an object of class \code{\link[lavaan:lavaan-class]{lavaan}}.
}
\description{
This fits a model estimating the possible hearsay reputation parameters
as a multi-group path model given some set of P1-, P2-, target self-reports,
P1-, and P2-third-person meta-perceptions
(vectors of quoted variable names) and a group-level categorical variable.
The baseline model estimates each parameter seperately,
labelling parameters based on the labels of moderator variable.
It fits a model estimating the possible hearsay reputation parameters given the input.
See specific model functions for which parameters are estimated for each model.
}
\details{
The function can handle up to n exchangeable triads.
}
\examples{
data("rep_sim_data")
          agree_full_3pmeta_grpmod <- rep_auto_group_mod(data = rep_sim_data,
                                                         p1_reports = c("A_C_agreeableness", "C_A_agreeableness"),
                                                         p2_reports = c("B_C_agreeableness", "D_A_agreeableness"),
                                                         target_self = c("C_C_agreeableness", "A_A_agreeableness"),
                                                         p1_meta = c("A_B_C_agree_meta", "C_D_A_agree_meta"),
                                                         p2_meta = c("B_A_C_agree_meta", "D_C_A_agree_meta"),
                                                         group_mod = "study")

         # You could constrain all parameters to be equal across all groups
         # by setting both the groups_eql and params_eql arguments to "all"
         agree_full_3pmeta_grpmod <- rep_auto_group_mod(data = rep_sim_data,
                                                        p1_reports = c("A_C_agreeableness", "C_A_agreeableness"),
                                                        p2_reports = c("B_C_agreeableness", "D_A_agreeableness"),
                                                        target_self = c("C_C_agreeableness", "A_A_agreeableness"),
                                                        p1_meta = c("A_B_C_agree_meta", "C_D_A_agree_meta"),
                                                        p2_meta = c("B_A_C_agree_meta", "D_C_A_agree_meta"),
                                                        group_mod = "study", groups_eql = "all", params_eql = "all")

         agree_con_acc_grpmod <- rep_auto_group_mod(data = rep_sim_data,
                                                        p1_reports = c("A_C_agreeableness", "C_A_agreeableness"),
                                                        p2_reports = c("B_C_agreeableness", "D_A_agreeableness"),
                                                        target_self = c("C_C_agreeableness", "A_A_agreeableness"),
                                                        group_mod = "study", groups_eql = "all", params_eql = "all")


}
