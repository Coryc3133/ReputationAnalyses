% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/reputation_model.R
\name{rep_analyses_auto}
\alias{rep_analyses_auto}
\title{Reputation Analyses (automatic)}
\usage{
rep_analyses_auto(data, p1_reports, p2_reports, target_self = NULL,
  p1_meta = NULL, p2_meta = NULL, n_triads = length(p1_reports),
  n_p1s_per_p2s = 1, n_p2s_per_p1s = 1, n_p1s_per_ts = 1,
  n_p2s_per_ts = 1, n_ts_per_p1s = 1, n_ts_per_p2s = 1)
}
\arguments{
\item{data}{The dataframe that contains ratings (P1, P2, target self-report, P1, and P2 meta-perceptions).
Data should be wide, with a row for every group of participants.
At a minimum, it must contain two columns: one for P1 reports and one for P2 reports.}

\item{p1_reports}{The column(s) that contain P1 reports,
or ratings made by the person that knows the target directly.
If more than one is supplied, the target-wise order must match the other
rating types.}

\item{p2_reports}{The column(s) that contain P2 reports,
or ratings made by the person that knows the target indirectly through the corresponding P1.
If more than one is supplied, the target-wise order must match the other
rating types.}

\item{target_self}{Optional. The column(s) that contain target self-reports.
If more than one is supplied, the target-wise order must match the other
rating types.}

\item{p1_meta}{Optional. The column(s) that contain P1 3rd person Meta-perceptions,
or P1's ratings of how they think P2 sees the target.
If more than one is supplied, the target-wise order must match the other
rating types.}

\item{p2_meta}{Optional. The column(s) that contain P2 3rd person Meta-perceptions,
or P2's ratings of how they think P1 sees the target.
If more than one is supplied, the target-wise order must match the other
rating types.}

\item{n_triads}{The number of exhangeable triads in each group. By default, this is determined by
counting the number of P1 reports. It is rare that this parameter would need to be changed manually.}

\item{n_p1s_per_p2s}{The number of P1s for every P2. This defaults to 1.
Currently, only values of 1 are supported.}

\item{n_p2s_per_p1s}{The number of P2s for every P1;. This defaults to 1.
Currently, only values of 1 are supported.}

\item{n_p1s_per_ts}{The number of P1s for every target;. This defaults to 1.
Currently, only values of 1 are supported.}

\item{n_p2s_per_ts}{The number of P2s for every target;. This defaults to 1.
Currently, only values of 1 are supported.}

\item{n_ts_per_p1s}{The number of targets for every P1;. This defaults to 1.
Currently, only values of 1 are supported.}

\item{n_ts_per_p2s}{The number of targets for every P2;. This defaults to 1.
Currently, only values of 1 are supported.}
}
\value{
The function returns an object of class \code{\link[lavaan:lavaan-class]{lavaan}}.
}
\description{
This is a wrapper function around the reputation model functions.
}
\details{
This chooses a function depending on which
variables are supplied. At a minimum, it requires a P1- & P2-ratings. It can
optionally take target self-reports and third-person meta-perceptions (for P1 and P2).
It fits a model estimating the possible hearsay reputation parameters given the input.
See specific model functions for which parameters are estimated for each model.

The function can handle up to n exchangeable triads.
}
\examples{
data("rep_sim_data")
 rep_analyses_auto(data = rep_sim_data,
                  p1_reports = c("A_C_agreeableness", "C_A_agreeableness"),
                  p2_reports = c("B_C_agreeableness", "D_A_agreeableness"))

 rep_analyses_auto(data = rep_sim_data,
                  p1_reports = c("A_C_agreeableness", "C_A_agreeableness"),
                  p2_reports = c("B_C_agreeableness", "D_A_agreeableness"),
                  target_self = c("C_C_agreeableness", "A_A_agreeableness"))

 rep_analyses_auto(data = rep_sim_data,
                  p1_reports = c("A_C_agreeableness", "C_A_agreeableness"),
                  p2_reports = c("B_C_agreeableness", "D_A_agreeableness"),
                  target_self = c("C_C_agreeableness", "A_A_agreeableness"),
                  p1_meta = c("A_B_C_agree_meta", "C_D_A_agree_meta"),
                  p2_meta = c("B_A_C_agree_meta", "D_C_A_agree_meta"))
}
