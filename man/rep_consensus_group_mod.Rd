% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/group_mods.R
\name{rep_consensus_group_mod}
\alias{rep_consensus_group_mod}
\title{Reputation Consensus with Group Moderator Model}
\usage{
rep_consensus_group_mod(data, model = NULL, p1_reports, p2_reports,
  group_mod = NULL, use_labs = TRUE, groups_eql = "none",
  params_eql = "none", n_triads = length(p1_reports),
  n_p1s_per_p2s = 1, n_p2s_per_p1s = 1)
}
\arguments{
\item{data}{The dataframe that contains P1 & P2 ratings and the group-level moderator.
Data should be wide, with a row for every group of participants.
At a minimum, it must contain three columns: one for P1 reports, one for P2 reports, and one for the group-level moderator.}

\item{model}{Optional. A model from the corresponding ReputationModelR model builder function. If this
is supplied, no additional arguments need to be specified.}

\item{p1_reports}{Quoted column names that contain P1 reports,
or ratings made by the person that knows the target directly.
If more than one is supplied, the target-wise order must match the other
rating types.}

\item{p2_reports}{Quoted column names that contain P2 reports,
or ratings made by the person that knows the target indirectly through the corresponding P1.
If more than one is supplied, the target-wise order must match the other
rating types.}

\item{group_mod}{The quoted column name that contains a group-level categorical moderator.}

\item{use_labs}{Logical indicating whether or not to use the group labels to create the parameter labels.
If FALSE, generic labels (grp1 to grpk, where k is the number of groups) are used.}

\item{groups_eql}{Optional. Groups that you want to constrain to be equal across some or all parameters. If
you have use_labs set to TRUE, provide a vector of group labels corresponding to the groups you want to constrain to be equal. If you
have use_labs set to FALSE, provide a vector of numbers corresponding to the position of the groups you want to constrain to be equal. If you provide
"all", all groups will be constrained to be equal.}

\item{params_eql}{Optional. Parameters that you want to constrain to be equal across the groups specified in groups_eql. You can provide
one or more specific parameters (e.g., "hc" for hearsay consensus), or use one of several built-in options including "all" which constrains
all parameters to be equal across groups and "main" which constrains just the hearsay consensus to be equal across groups (in this model).}

\item{n_triads}{The number of exchangeable triads in each group. By default, this is determined by
counting the number of P1 reports. This parameter rarely needs to be changed.}

\item{n_p1s_per_p2s}{The number of P1s for every P2. This defaults to 1.
Currently, only values of 1 are supported.}

\item{n_p2s_per_p1s}{The number of P2s for every P1;. This defaults to 1.
Currently, only values of 1 are supported.}
}
\value{
The function returns an object of class \code{\link[lavaan:lavaan-class]{lavaan}}.
}
\description{
This fits a model estimating the possible hearsay reputation parameters
as a multi-group path model given vectors of P1 and P2 reports (vectors of quoted variable names)
and a group-level categorical variable.
The baseline model estimates each parameter seperately,
labelling parameters based on the labels of moderator variable.
Those parameters are:
\describe{
\item{hc}{hearsay consensus; the correlation between P1(T) & P2(T)}
\item{int_p1}{Intercept for P1(T)}
\item{int_p2}{Intercept for P2(T)}
\item{v_p1}{variance for P1(T)}
\item{v_p2}{variance for P2(T)}
\item{p1_p2_rel_el}{P1-P2 Relative Elevation (i.e., Mean P1(T) - Mean P2(T))}
}
\emph{If n exchangeable triads > 1:}
\describe{
\item{rec}{direct reciprocity; the correlation between opposit P1(T)s (e.g., A(C) <-> C(A))}
\item{h}{hearsay reciprocity; the correlation between exchangeable P2(T)s (e.g., B(C) <-> D(A))}
\item{m}{unnamed parameter; The correlation between P2(T) and the opposite P1(T) in a group. (e.g., B(C) <-> C(A))}
}
The function can handle up to n exchangeable triads.
}
\examples{
data("rep_sim_data")
          agree_consensus_grpmod <- rep_consensus_group_mod(data = rep_sim_data,
                                                            p1_reports = c("A_C_agreeableness", "C_A_agreeableness"),
                                                            p2_reports = c("B_C_agreeableness", "D_A_agreeableness"),
                                                            group_mod = "study")
         # alternatively
         # build the model
          agree_consensus_grpmod_model <- rep_consensus_group_mod_builder(p1_reports = c("A_C_agreeableness", "C_A_agreeableness"),
                                                                          p2_reports = c("B_C_agreeableness", "D_A_agreeableness"),
                                                                          groups = levels(rep_sim_data$study))
         # then fit it
         agree_consensus_grpmod <- rep_consensus_group_mod(data = rep_sim_data,
                                                           model = agree_consensus_grpmod_model,
                                                           group_mod = "study")

         # fit model with group equality constraints:
         # if we wanted to constrain all parameters to be equal across the 2 groups, that can be done
         # by setting groups_eql and params_eql both to "all".
        agree_consensus_grpmod <- rep_consensus_group_mod(data = rep_sim_data,
                                                          p1_reports = c("A_C_agreeableness", "C_A_agreeableness"),
                                                          p2_reports = c("B_C_agreeableness", "D_A_agreeableness"),
                                                          group_mod = "study",
                                                          groups_eql = "all",
                                                          params_eql = "all")

        # Or we could constrain just hearsay consensus to be equal
         agree_consensus_grpmod <- rep_consensus_group_mod(data = rep_sim_data,
                                                       p1_reports = c("A_C_agreeableness", "C_A_agreeableness"),
                                                       p2_reports = c("B_C_agreeableness", "D_A_agreeableness"),
                                                       group_mod = "study",
                                                       groups_eql = "all",
                                                       params_eql = c("hc", "v_p1", "v_p2"))

       # It can also handle more groups, and groups without unlabelled groups.
       # The simulated dataset has the group_var variable, which is contains
       # 4 groups, each labelled with just a number (1 to 4). To use an unlabelled group
       # either set use_labs to FALSE or it will do so for you.
       agree_4grp_consensus_fit <- rep_consensus_group_mod(data = rep_sim_data,
                                                       p1_reports = c("A_C_agreeableness", "C_A_agreeableness"),
                                                       p2_reports = c("B_C_agreeableness", "D_A_agreeableness"),
                                                       group_mod = "group_var")

      # for unlabelled groups (or whenever use_labs = FALSE), you can select certain groups for equality constraints
      # by passing a vector of group numbers that should be constrained to be equal. For example, if we wanted
      # just groups 1 and 3 to be equal, we would set groups_eql to c(1, 3), like so:
       agree_4grp_consensus_fit <- rep_consensus_group_mod(data = rep_sim_data,
                                                       p1_reports = c("A_C_agreeableness", "C_A_agreeableness"),
                                                       p2_reports = c("B_C_agreeableness", "D_A_agreeableness"),
                                                       group_mod = "group_var",
                                                       groups_eql = c(1, 3),
                                                       params_eql = "all")

}
